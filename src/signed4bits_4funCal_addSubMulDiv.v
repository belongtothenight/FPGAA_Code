
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_LITE(
	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW

);



//=======================================================
//  REG/WIRE declarations
//=======================================================

// this is signed 4bits adder/substractor/multiplier/divider

wire signed [4:0] numA, numB;    // for calculation
wire [3:0] numA_ten, numA_digit; // for display
wire [3:0] numB_ten, numB_digit;

wire signed [5:0] num_Add, num_Sub;
wire [3:0] num_Add_ten, num_Add_digit;
wire [3:0] num_Sub_ten, num_Sub_digit;

wire signed [9:0] num_Mul;
wire [3:0] num_Mul_hundred, num_Mul_ten, num_Mul_digit;

wire signed [5:0] num_Div_Q, num_Div_R;
wire [3:0] num_Div_Q_ten, num_Div_Q_digit;
wire [3:0] num_Div_R_ten, num_Div_R_digit;

reg [3:0] digit0, digit1, digit2, digit3, digit4, digit5;

//=======================================================
//  Structural coding
//=======================================================

/*
KEY0 | UNPRESSED | PRESSED   | UNPRESSED | PRESSED   |
KEY1 | UNPRESSED | UNPRESSED | PRESSED   | PRESSED   |
FUNC | ADD	     | SUB       | MUL       | DIV       |
*/

assign numA = SW[4]?32-SW[3:0]:SW[3:0];
assign numB = SW[9]?32-SW[8:5]:SW[9:5];
assign numA_digit = SW[3:0]%10;
assign numA_ten   = SW[3:0]/10;
assign numB_digit = SW[8:5]%10;
assign numB_ten   = SW[8:5]/10;

assign num_Add = numB + numA;
assign num_Sub = numB - numA;
assign num_Mul = numB * numA;
assign num_Div_Q = numB / numA;
assign num_Div_R = numB % numA;

assign num_Add_ten     = num_Add[5]?(32-num_Add[4:0])/10:num_Add/10;
assign num_Add_digit   = num_Add[5]?(32-num_Add[4:0])%10:num_Add%10;
assign num_Sub_ten     = num_Sub[5]?(32-num_Sub[4:0])/10:num_Sub/10;
assign num_Sub_digit   = num_Sub[5]?(32-num_Sub[4:0])%10:num_Sub%10;
assign num_Mul_hundred = num_Mul[9]?(512-num_Mul[8:0])/100:num_Mul/100;
assign num_Mul_ten     = num_Mul[9]?((512-num_Mul[8:0])%100)/10:(num_Mul%100)/10;
assign num_Mul_digit   = num_Mul[9]?((512-num_Mul[8:0])%100)%10:(num_Mul%100)%10;
assign num_Div_Q_ten   = num_Div_Q[5]?(32-num_Div_Q[4:0])/10:num_Div_Q/10;
assign num_Div_Q_digit = num_Div_Q[5]?(32-num_Div_Q[4:0])%10:num_Div_Q%10;
assign num_Div_R_ten   = num_Div_R[5]?(32-num_Div_R[4:0])/10:num_Div_R/10;
assign num_Div_R_digit = num_Div_R[5]?(32-num_Div_R[4:0])%10:num_Div_R%10;

always @(KEY[0] or KEY[1])
begin
	if (KEY[0] && KEY[1])       // input mode: not pressed key 0,1
	begin
		digit5 = 4'he;
		digit4 = 4'he;
		digit3 = 4'he;
		digit2 = num_Add[5]?4'hf:4'he;
		digit1 = num_Add_ten;
		digit0 = num_Add_digit;
	end
	else if (!KEY[0] && KEY[1]) // add mode: pressed key 0
	begin
		digit5 = 4'he;
		digit4 = 4'he;
		digit3 = 4'he;
		digit2 = num_Sub[5]?4'hf:4'he;
		digit1 = num_Sub_ten;
		digit0 = num_Sub_digit;
	end
	else if (KEY[0] && !KEY[1]) // sub mode: pressed key 1
	begin
		digit5 = 4'he;
		digit4 = 4'he;
		digit3 = num_Mul[9]?4'hf:4'he;
		digit2 = num_Mul_hundred;
		digit1 = num_Mul_ten;
		digit0 = num_Mul_digit;
	end
	else if (!KEY[0] && !KEY[1]) // div mode: pressed key 0,1
	begin
		if (numA != 0)
		begin
			digit5 = num_Div_Q[5]?4'hf:4'he;
			digit4 = num_Div_Q_ten;
			digit3 = num_Div_Q_digit;
			digit2 = 4'he;
			digit1 = num_Div_R_ten;
			digit0 = num_Div_R_digit;
		end
		else 
		begin
			digit5 = 4'hf;
			digit4 = 4'hf;
			digit3 = 4'hf;
			digit2 = 4'hf;
			digit1 = 4'hf;
			digit0 = 4'hf;
		end
	end
end

SEG7_LUT_6 u_seg(
	.oSEG0(HEX0),
	.oSEG1(HEX1),
	.oSEG2(HEX2),
	.oSEG3(HEX3),
	.oSEG4(HEX4),
	.oSEG5(HEX5),
	.iDIG ({ digit5, digit4, digit3, digit2, digit1, digit0})
);
	
endmodule
